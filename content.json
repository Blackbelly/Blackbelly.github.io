{"meta":{"title":"Another","subtitle":null,"description":null,"author":"blackbelly","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-06-28T19:20:52.000Z","updated":"2019-06-28T19:20:52.768Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-28T19:21:04.000Z","updated":"2019-06-28T19:21:04.230Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-02-21T02:24:14.000Z","updated":"2018-02-21T02:24:14.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"PEP-3333 翻译","slug":"PEP-3333 翻译","date":"2018-02-20T13:25:57.000Z","updated":"2018-02-20T15:26:10.000Z","comments":true,"path":"2018/02/20/PEP-3333 翻译/","link":"","permalink":"http://yoursite.com/2018/02/20/PEP-3333 翻译/","excerpt":"","text":"PEP 3333 python wsgi此外, 为了让已有的或者未来的框架和服务能够轻易实现, wsgi 应该能够很容易的创建 request 的预处理器, response 的 post 处理器, 以及其他基于 wsgi 中间件的部件, 从而使其对于 server 来说像一个 app, 而对于 app 来说又像一个 server specification overviewwsgi 接口有两个方面, 服务端(网关端), 以及应用端(框架端). 服务端包含了一个能够调用的对象, 提供给 app 使用, 具体提供的对象取决于 server 端, 假设有些 server 需要 app 的部署者写一些简单的脚本去创建 server 对象, 提供 app 对象. 其他的 server 可以使用具体的配置文件或其他途径去指定 application 应该从哪导入, 或是如何获得. 此外, 纯 server 和 application 也可以创建中间件去实现这两种特性. 某些组件, 对于其内部的 server 来说, 其行为就像一个 application, 而对于其内部的 application 来说, 又像是一个 server, 并且能够提供拓展的 api 接口, 文本转换, 导航, 或者其他有用的功能 The application / framwork sideapplication 对象是一个接受两个参数的简单可调用对象. 术语’对象’不应误解为一个对象实例: 函数, 方法, 类, 或者带有 __call__ 方法的实例都可以认为是一个 application 对象. 12345678910111213141516171819202122232425262728293031323334HELLO_WORLD = b&quot;Hello world!\\n&quot;def simple_app(environ, start_response): &quot;&quot;&quot;Simplest possible application object&quot;&quot;&quot; &quot;&quot;&quot;application 对象, 接受两个参数, 能够被调用&quot;&quot;&quot; status = &apos;200 OK&apos; response_headers = [(&apos;Content-type&apos;, &apos;text/plain&apos;)] start_response(status, response_headers) return [HELLO_WORLD]class AppClass: &quot;&quot;&quot;Produce the same output, but using a class (Note: &apos;AppClass&apos; is the &quot;application&quot; here, so calling it returns an instance of &apos;AppClass&apos;, which is then the iterable return value of the &quot;application callable&quot; as required by the spec. If we wanted to use *instances* of &apos;AppClass&apos; as application objects instead, we would have to implement a &apos;__call__&apos; method, which would be invoked to execute the application, and we would need to create an instance for use by the server or gateway. &quot;&quot;&quot; def __init__(self, environ, start_response): self.environ = environ self.start = start_response def __iter__(self): status = &apos;200 OK&apos; response_headers = [(&apos;Content-type&apos;, &apos;text/plain&apos;)] self.start(status, response_headers) yield HELLO_WORLD The Server / Gateway Sideserver or gateway 为 http client 的每个请求调起一次 application. 下面有个简单的 CGI gateway, 实现了一个带有 application 对象的函数. 需要注意的是这个简单例子的 error handle 十分有限, 默认会将未捕获到的异常抛出为 sys.stderr , 并通过 web server 记录日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import os, sysenc, esc = sys.getfilesystemencoding(), &apos;surrogateescape&apos;def unicode_to_wsgi(u): # Convert an environment variable to a WSGI &quot;bytes-as-unicode&quot; string return u.encode(enc, esc).decode(&apos;iso-8859-1&apos;)def wsgi_to_bytes(s): return s.encode(&apos;iso-8859-1&apos;)def run_with_cgi(application): environ = &#123;k: unicode_to_wsgi(v) for k,v in os.environ.items()&#125; environ[&apos;wsgi.input&apos;] = sys.stdin.buffer environ[&apos;wsgi.errors&apos;] = sys.stderr environ[&apos;wsgi.version&apos;] = (1, 0) environ[&apos;wsgi.multithread&apos;] = False environ[&apos;wsgi.multiprocess&apos;] = True environ[&apos;wsgi.run_once&apos;] = True if environ.get(&apos;HTTPS&apos;, &apos;off&apos;) in (&apos;on&apos;, &apos;1&apos;): environ[&apos;wsgi.url_scheme&apos;] = &apos;https&apos; else: environ[&apos;wsgi.url_scheme&apos;] = &apos;http&apos; headers_set = [] headers_sent = [] def write(data): out = sys.stdout.buffer if not headers_set: raise AssertionError(&quot;write() before start_response()&quot;) elif not headers_sent: # Before the first output, send the stored headers status, response_headers = headers_sent[:] = headers_set out.write(wsgi_to_bytes(&apos;Status: %s\\r\\n&apos; % status)) for header in response_headers: out.write(wsgi_to_bytes(&apos;%s: %s\\r\\n&apos; % header)) out.write(wsgi_to_bytes(&apos;\\r\\n&apos;)) out.write(data) out.flush() def start_response(status, response_headers, exc_info=None): if exc_info: try: if headers_sent: # Re-raise original exception if headers sent raise exc_info[1].with_traceback(exc_info[2]) finally: exc_info = None # avoid dangling circular ref elif headers_set: raise AssertionError(&quot;Headers already set!&quot;) headers_set[:] = [status, response_headers] # Note: error checking on the headers should happen here, # *after* the headers are set. That way, if an error # occurs, start_response can only be re-called with # exc_info set. return write result = application(environ, start_response) try: for data in result: if data: # don&apos;t send headers until body appears write(data) if not headers_sent: write(&apos;&apos;) # send headers now if body was empty finally: if hasattr(result, &apos;close&apos;): result.close()","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-20T12:28:39.000Z","updated":"2018-02-21T03:50:48.000Z","comments":true,"path":"2018/02/20/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}